/**
 * Copyright (C) 2009 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.financial.currency;

import java.util.HashSet;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.opengamma.core.historicaltimeseries.HistoricalTimeSeries;
import com.opengamma.core.value.MarketDataRequirementNames;
import com.opengamma.engine.ComputationTarget;
import com.opengamma.engine.ComputationTargetSpecification;
import com.opengamma.engine.function.AbstractFunction;
import com.opengamma.engine.function.FunctionCompilationContext;
import com.opengamma.engine.function.FunctionExecutionContext;
import com.opengamma.engine.function.FunctionInputs;
import com.opengamma.engine.marketdata.ExternalIdBundleLookup;
import com.opengamma.engine.target.ComputationTargetType;
import com.opengamma.engine.value.ComputedValue;
import com.opengamma.engine.value.ValueProperties;
import com.opengamma.engine.value.ValueRequirement;
import com.opengamma.engine.value.ValueRequirementNames;
import com.opengamma.engine.value.ValueSpecification;
import com.opengamma.financial.OpenGammaCompilationContext;
import com.opengamma.financial.analytics.timeseries.DateConstraint;
import com.opengamma.financial.analytics.timeseries.HistoricalTimeSeriesFunctionUtils;
import com.opengamma.financial.currency.CurrencyMatrixValue.CurrencyMatrixCross;
import com.opengamma.financial.currency.CurrencyMatrixValue.CurrencyMatrixFixed;
import com.opengamma.financial.currency.CurrencyMatrixValue.CurrencyMatrixValueRequirement;
import com.opengamma.id.ExternalIdBundle;
import com.opengamma.id.UniqueId;
import com.opengamma.master.historicaltimeseries.HistoricalTimeSeriesResolutionResult;
import com.opengamma.master.historicaltimeseries.HistoricalTimeSeriesResolver;
import com.opengamma.util.money.Currency;
import com.opengamma.util.timeseries.DoubleTimeSeries;
import com.opengamma.util.tuple.Pair;

/**
 * Injects a value from a {@link CurrencyMatrix} into a dependency graph to satisfy the currency requirements generated by {@link CurrencyConversionFunction}.
 */
public class CurrencyMatrixSourcingFunction extends AbstractFunction.NonCompiledInvoker {

  private static final Logger s_logger = LoggerFactory.getLogger(CurrencyMatrixSourcingFunction.class);

  private static final String CURRENCY_MATRIX_NAME_PROPERTY = "CurrencyMatrix";

  private static final ExternalIdBundleLookup s_externalIdLookup = new ExternalIdBundleLookup(null);

  /**
   * Scheme used for the target primitive.
   */
  public static final String TARGET_IDENTIFIER_SCHEME = "CurrencyPair";

  private final String _currencyMatrixName;
  private final String[] _additionalProperties;
  private CurrencyMatrix _currencyMatrix;
  private HistoricalTimeSeriesResolver _htsResolver;

  public CurrencyMatrixSourcingFunction(final String currencyMatrixName) {
    _currencyMatrixName = currencyMatrixName;
    _additionalProperties = null;
  }

  public CurrencyMatrixSourcingFunction(final String[] params) {
    _currencyMatrixName = params[0];
    _additionalProperties = new String[params.length - 1];
    System.arraycopy(params, 1, _additionalProperties, 0, _additionalProperties.length);
  }

  @Override
  protected ValueProperties.Builder createValueProperties() {
    final ValueProperties.Builder properties = super.createValueProperties();
    properties.with(CURRENCY_MATRIX_NAME_PROPERTY, _currencyMatrixName);
    if (_additionalProperties != null) {
      for (int i = 0; i < _additionalProperties.length; i += 2) {
        properties.with(_additionalProperties[i], _additionalProperties[i + 1]);
      }
    }
    return properties;
  }

  private static Pair<Currency, Currency> parse(final UniqueId uniqueId) {
    final String value = uniqueId.getValue();
    if (value.length() != 6) {
      return null;
    }
    final Currency source = Currency.of(value.substring(0, 3));
    final Currency target = Currency.of(value.substring(3));
    return Pair.of(source, target);
  }

  protected CurrencyMatrix getCurrencyMatrix() {
    return _currencyMatrix;
  }

  protected void setCurrencyMatrix(final CurrencyMatrix currencyMatrix) {
    _currencyMatrix = currencyMatrix;
  }

  protected String getCurrencyMatrixName() {
    return _currencyMatrixName;
  }

  protected void setHistoricalTimeSeriesResolver(final HistoricalTimeSeriesResolver htsResolver) {
    _htsResolver = htsResolver;
  }

  protected HistoricalTimeSeriesResolver getHistoricalTimeSeriesResolver() {
    return _htsResolver;
  }

  @Override
  public void init(final FunctionCompilationContext context) {
    // TODO: [PLAT-2286] This is flawed. The matrix sourcing function should use the resolved matrix as its target so that changes to it will cause
    // re-evaluation. The rate sourcing function should request the value it needs from the sourcing function using constraints to specify the currency
    // pair. E.g. { ticker(s) } -> CurrencyMatrixSourcingFunction(CurrencyMatrix~DEFAULT) -> { Rate(CurrencyMatrix~DEFAULT, Source=USD, Target=GBP) }
    //            { Rate(CurrencyMatrix~DEFAULT, Source=USD, Target=GBP) } -> CurrencyRateSourcingFunction(CurrencyPair~USD_GBP) -> { Rate(CurrencyPair~USD_GBP) }
    // There is a single CurrencyMatrixSourcingFunction in the function repository, there are multiple CurrencyRateSourcingFunctions that correspond
    // to injecting the required matrix name
    final CurrencyMatrix matrix = OpenGammaCompilationContext.getCurrencyMatrixSource(context).getCurrencyMatrix(getCurrencyMatrixName());
    setCurrencyMatrix(matrix);
    if (matrix != null) {
      if (matrix.getUniqueId() != null) {
        context.getFunctionReinitializer().reinitializeFunction(this, matrix.getUniqueId().getObjectId());
      }
    }
    setHistoricalTimeSeriesResolver(OpenGammaCompilationContext.getHistoricalTimeSeriesResolver(context));
  }

  @Override
  public ComputationTargetType getTargetType() {
    // TODO: [PLAT-2286] Should have a type declared locally in this package for CurrencyPair; this would remove the need for the RATE_LOOKUP_SCHEME constant
    // in CurrencyConversionFunction.
    return ComputationTargetType.PRIMITIVE;
  }

  @Override
  public boolean canApplyTo(final FunctionCompilationContext context, final ComputationTarget target) {
    if (getCurrencyMatrix() == null) {
      return false;
    }
    if (target.getUniqueId() == null) {
      return false;
    }
    if (!TARGET_IDENTIFIER_SCHEME.equals(target.getUniqueId().getScheme())) {
      return false;
    }
    final Pair<Currency, Currency> currencies = parse(target.getUniqueId());
    if (currencies == null) {
      return false;
    }
    return true;
  }

  @Override
  public Set<ValueSpecification> getResults(final FunctionCompilationContext context, final ComputationTarget target) {
    final ComputationTargetSpecification targetSpec = target.toSpecification();
    final ValueProperties properties = createValueProperties().get();
    final Set<ValueSpecification> results = new HashSet<ValueSpecification>();
    results.add(new ValueSpecification(ValueRequirementNames.SPOT_RATE, targetSpec, properties));
    if (getHistoricalTimeSeriesResolver() != null) {
      results.add(new ValueSpecification(CurrencySeriesConversionFunction.SPOT_RATE, targetSpec, properties));
    }
    return results;
  }

  private boolean getValueConversionRequirements(final Set<ValueRequirement> requirements, final Set<Pair<Currency, Currency>> visited, final Pair<Currency, Currency> currencies) {
    if (!visited.add(currencies)) {
      // Gone round in a loop if we've already seen this pair
      throw new IllegalStateException();
    }
    final CurrencyMatrixValue value = getCurrencyMatrix().getConversion(currencies.getFirst(), currencies.getSecond());
    if (value != null) {
      return value.accept(new CurrencyMatrixValueVisitor<Boolean>() {

        @Override
        public Boolean visitCross(final CurrencyMatrixCross cross) {
          return getValueConversionRequirements(requirements, visited, Pair.of(currencies.getFirst(), cross.getCrossCurrency()))
              && getValueConversionRequirements(requirements, visited, Pair.of(cross.getCrossCurrency(), currencies.getSecond()));
        }

        @Override
        public Boolean visitFixed(final CurrencyMatrixFixed fixedValue) {
          // Literal value - nothing required
          return Boolean.TRUE;
        }

        @Override
        public Boolean visitValueRequirement(final CurrencyMatrixValueRequirement valueRequirement) {
          requirements.add(valueRequirement.getValueRequirement());
          return Boolean.TRUE;
        }

      });
    } else {
      return false;
    }
  }

  private ValueRequirement getSeriesConversionRequirement(final CurrencyMatrixValueRequirement valueRequirement) {
    final ValueRequirement requirement = valueRequirement.getValueRequirement();
    final ExternalIdBundle targetIdentifiers = s_externalIdLookup.getExternalIds(requirement.getTargetReference());
    final HistoricalTimeSeriesResolutionResult timeSeries = getHistoricalTimeSeriesResolver().resolve(targetIdentifiers, null, null, null, MarketDataRequirementNames.MARKET_VALUE, null);
    if (timeSeries == null) {
      return null;
    }
    // TODO: Requesting the whole time series isn't ideal but we don't know which points will be needed. Could the time series somehow be a lazy-fetch?
    // Is this really a problem - caching the whole time series at a calc node may be better than requesting different subsets each time?
    return HistoricalTimeSeriesFunctionUtils.createHTSRequirement(timeSeries, MarketDataRequirementNames.MARKET_VALUE, DateConstraint.EARLIEST_START, true,
        DateConstraint.VALUATION_TIME, true);
  }

  private boolean getSeriesConversionRequirements(final Set<ValueRequirement> requirements, final Set<Pair<Currency, Currency>> visited, final Pair<Currency, Currency> currencies) {
    if (!visited.add(currencies)) {
      // Gone round in a loop if we've already seen this pair
      throw new IllegalStateException();
    }
    final CurrencyMatrixValue value = getCurrencyMatrix().getConversion(currencies.getFirst(), currencies.getSecond());
    if (value != null) {
      return value.accept(new CurrencyMatrixValueVisitor<Boolean>() {

        @Override
        public Boolean visitCross(final CurrencyMatrixCross cross) {
          return getSeriesConversionRequirements(requirements, visited, Pair.of(currencies.getFirst(), cross.getCrossCurrency()))
              && getSeriesConversionRequirements(requirements, visited, Pair.of(cross.getCrossCurrency(), currencies.getSecond()));
        }

        @Override
        public Boolean visitFixed(final CurrencyMatrixFixed fixedValue) {
          // Literal value - nothing required
          return Boolean.TRUE;
        }

        @Override
        public Boolean visitValueRequirement(final CurrencyMatrixValueRequirement valueRequirement) {
          final ValueRequirement requirement = getSeriesConversionRequirement(valueRequirement);
          if (requirement == null) {
            return Boolean.FALSE;
          }
          requirements.add(requirement);
          return Boolean.TRUE;
        }

      });
    } else {
      return false;
    }
  }

  @Override
  public Set<ValueRequirement> getRequirements(final FunctionCompilationContext context, final ComputationTarget target, final ValueRequirement desiredValue) {
    final Pair<Currency, Currency> currencies = parse(target.getUniqueId());
    final Set<ValueRequirement> requirements = new HashSet<ValueRequirement>();
    if (ValueRequirementNames.SPOT_RATE.equals(desiredValue.getValueName())) {
      if (!getValueConversionRequirements(requirements, new HashSet<Pair<Currency, Currency>>(), currencies)) {
        return null;
      }
    } else {
      if (!getSeriesConversionRequirements(requirements, new HashSet<Pair<Currency, Currency>>(), currencies)) {
        return null;
      }
    }
    return requirements;
  }

  private static Object createCrossRate(final Object r1, final Object r2) {
    if (r1 instanceof Double) {
      if (r2 instanceof Double) {
        return (Double) r1 * (Double) r2;
      } else if (r2 instanceof DoubleTimeSeries) {
        return ((DoubleTimeSeries<?>) r2).multiply((Double) r1);
      } else {
        throw new IllegalArgumentException();
      }
    } else if (r1 instanceof DoubleTimeSeries) {
      if (r2 instanceof Double) {
        return ((DoubleTimeSeries<?>) r1).multiply((Double) r2);
      } else if (r2 instanceof DoubleTimeSeries) {
        return ((DoubleTimeSeries<?>) r1).multiply((DoubleTimeSeries<?>) r2);
      } else {
        throw new IllegalArgumentException();
      }
    } else {
      throw new IllegalArgumentException();
    }
  }

  private Object getValueConversionRate(final FunctionInputs inputs, final Currency source, final Currency target) {
    final CurrencyMatrixValue value = getCurrencyMatrix().getConversion(source, target);
    final Object rate = value.accept(new CurrencyMatrixValueVisitor<Object>() {

      @Override
      public Object visitCross(final CurrencyMatrixCross cross) {
        final Object r1 = getValueConversionRate(inputs, source, cross.getCrossCurrency());
        final Object r2 = getValueConversionRate(inputs, cross.getCrossCurrency(), target);
        return createCrossRate(r1, r2);
      }

      @Override
      public Object visitFixed(final CurrencyMatrixFixed fixedValue) {
        return fixedValue.getFixedValue();
      }

      @Override
      public Object visitValueRequirement(final CurrencyMatrixValueRequirement valueRequirement) {
        final Object marketValue = inputs.getValue(valueRequirement.getValueRequirement());
        if (marketValue instanceof Number) {
          double rate = ((Number) marketValue).doubleValue();
          if (valueRequirement.isReciprocal()) {
            rate = 1.0 / rate;
          }
          return rate;
        } else if (marketValue instanceof DoubleTimeSeries) {
          DoubleTimeSeries<?> rate = (DoubleTimeSeries<?>) marketValue;
          if (valueRequirement.isReciprocal()) {
            rate = rate.reciprocal();
          }
          return rate;
        } else {
          throw new IllegalArgumentException(valueRequirement.toString());
        }
      }

    });
    s_logger.debug("{} to {} = {}", new Object[] {source, target, rate });
    return rate;
  }

  private Object getSeriesConversionRate(final FunctionInputs inputs, final Currency source, final Currency target) {
    final CurrencyMatrixValue value = getCurrencyMatrix().getConversion(source, target);
    final Object rate = value.accept(new CurrencyMatrixValueVisitor<Object>() {

      @Override
      public Object visitCross(final CurrencyMatrixCross cross) {
        final Object r1 = getSeriesConversionRate(inputs, source, cross.getCrossCurrency());
        final Object r2 = getSeriesConversionRate(inputs, cross.getCrossCurrency(), target);
        return createCrossRate(r1, r2);
      }

      @Override
      public Object visitFixed(final CurrencyMatrixFixed fixedValue) {
        return fixedValue.getFixedValue();
      }

      @Override
      public Object visitValueRequirement(final CurrencyMatrixValueRequirement valueRequirement) {
        final Object marketValue = inputs.getValue(getSeriesConversionRequirement(valueRequirement));
        if (marketValue instanceof DoubleTimeSeries) {
          //TODO is this branch ever reached?
          DoubleTimeSeries<?> fxRate = (DoubleTimeSeries<?>) marketValue;
          if (valueRequirement.isReciprocal()) {
            fxRate = fxRate.reciprocal();
          }
          return fxRate;
        } else if (marketValue instanceof HistoricalTimeSeries) {
          DoubleTimeSeries<?> fxRate = ((HistoricalTimeSeries) marketValue).getTimeSeries();
          if (valueRequirement.isReciprocal()) {
            fxRate = fxRate.reciprocal();
          }
          return fxRate;
        } else {
          if (marketValue == null) {
            throw new IllegalArgumentException("Null time series for " + valueRequirement.toString());
          }
          throw new IllegalArgumentException("Expected a time series for " + valueRequirement.toString() + ", got " + marketValue.getClass());
        }
      }

    });
    s_logger.debug("{} to {} = {}", new Object[] {source, target, rate });
    return rate;
  }

  @Override
  public Set<ComputedValue> execute(final FunctionExecutionContext executionContext, final FunctionInputs inputs, final ComputationTarget target, final Set<ValueRequirement> desiredValues) {
    final Pair<Currency, Currency> currencies = parse(target.getUniqueId());
    final Set<ComputedValue> results = new HashSet<>();
    final ComputationTargetSpecification targetSpec = target.toSpecification();
    for (final ValueRequirement desiredValue : desiredValues) {
      final Object result;
      if (ValueRequirementNames.SPOT_RATE.equals(desiredValue.getValueName())) {
        result = getValueConversionRate(inputs, currencies.getFirst(), currencies.getSecond());
      } else {
        assert CurrencySeriesConversionFunction.SPOT_RATE.equals(desiredValue.getValueName());
        result = getSeriesConversionRate(inputs, currencies.getFirst(), currencies.getSecond());
      }
      results.add(new ComputedValue(new ValueSpecification(desiredValue.getValueName(), targetSpec, desiredValue.getConstraints()), result));
    }
    return results;
  }

  public int getPriority() {
    if (_currencyMatrixName.contains(CurrencyMatrixConfigPopulator.SYNTHETIC_LIVE_DATA)) {
      return -1;
    }
    return 0;
  }

  /**
   * Creates a requirement that will supply a value which gives the number of units of the source currency for each unit of the target currency.
   *
   * @param source the source currency to convert from
   * @param target the target currency to convert to
   * @return the requirement, not null
   */
  public static ValueRequirement getConversionRequirement(final Currency source, final Currency target) {
    return getConversionRequirement(source.getCode(), target.getCode());
  }

  /**
   * Creates a requirement that will supply a value which gives the number of units of the source currency for each unit of the target currency.
   *
   * @param source the source currency to convert from
   * @param target the target currency to convert to
   * @return the requirement, not null
   */
  public static ValueRequirement getConversionRequirement(final String source, final String target) {
    return new ValueRequirement(ValueRequirementNames.SPOT_RATE, ComputationTargetType.PRIMITIVE, UniqueId.of(TARGET_IDENTIFIER_SCHEME, source + target));
  }

  public static ValueRequirement getSeriesConversionRequirement(final Currency source, final Currency target) {
    return getSeriesConversionRequirement(source.getCode(), target.getCode());
  }

  public static ValueRequirement getSeriesConversionRequirement(final String source, final String target) {
    return new ValueRequirement(CurrencySeriesConversionFunction.SPOT_RATE, ComputationTargetType.PRIMITIVE, UniqueId.of(TARGET_IDENTIFIER_SCHEME, source + target));
  }

}
